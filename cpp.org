#+title: Cpp
#+description: C++ Programming
#+author: RP
#+STARTUP: fold

* Function
** Function Calling
*** Call by value
#+begin_src C++
  #include<iostream>
  using namespace std;
  int sum(int, int);
  int main(){
    int a=5,b=6;
    int s=sum(a,b);
    cout<<s;
  }
  int sum(int x, int y)
  {return(x+y);}
#+end_src

#+RESULTS:
: 11

*** Call by address
#+begin_src C++
  #include<iostream>
  using namespace std;
  int sum(int *, int *);
  int main(){
    int a=5,b=6;
    int s=sum(&a,&b);
    cout<<s;
  }
  int sum(int *x, int *y)
  {return(*x+*y);}
#+end_src

#+RESULTS:
: 11

*** Call by Reference
#+begin_src C++
  #include<iostream>
  using namespace std;
  int sum(int &, int &);
  int main(){
    int a=5,b=6;
    int s=sum(a,b);
    cout<<s;
  }
  int sum(int &x, int &y)
  {return(x+y);}
#+end_src

#+RESULTS:
: 11

** Default Arguments
#+begin_src C++
    #include<iostream>
    using namespace std;
    int add(int,int=0,int=0);
    int main(){
        int a,b,c;
        a=5,b=6;//cin>>a>>b;
        cout<<add(a,b)<<endl;
        c=7;//cin>>a>>b>>c;
        cout<<add(a,b,c);
    }
    int add(int x,int y,int z)
    {return(x+y+z);}
#+end_src

#+RESULTS:
| 11 |
| 18 |

** Function Overloading
#+begin_src C++ :results output
#include<iostream>
using namespace std;
int area(int,int);
float area(int);
int main(){
    int r=5;
    float A=area(r);
    cout<<"area of circle: "<<A<<endl;
    int l,b;
    int a=area(5,6);
    cout<<"area of rectangle: "<<a<<endl;
    return 0;
    }
float area(int radius){return 3.14*radius*radius;}
int area(int length,int breath){return 2*(length+breath);}
#+end_src

#+RESULTS:
: area of circle: 78.5
: area of rectangle: 22

1. C++ tries to find an exact match.
2. If no exact match is found, C++ tries to find a match through promotion
  - Char, unsigned char, short is promoted to int
  - Float is promoted to double
3. If no promotion is found, C++ tries to find a match through standard conversion

** Inline Function
#+begin_src C++ :results output
#include<iostream>
using namespace std;
inline void fun();
int main(){
    fun();
    return 0;
    }
void fun(){cout<<"fun";}
#+end_src

#+RESULTS:
: fun

** Function Pointer
#+begin_src C++ :results output
#include<iostream>
using namespace std;
void HelloWorld(){cout<<"hello world"<<endl;}
int main(){
    void(*func)() = &HelloWorld;
    // auto func = HelloWorld;
    func();
    typedef void(*hello_world)();
    hello_world h1=HelloWorld;
    }
#+end_src

#+RESULTS:
: hello world

#+begin_src C++ :results output
#include<iostream>
#include<vector>
using namespace std;
void printValue(int val){cout<<val<<endl;}
void ForEach(const vector<int>& v, void(*func)(int))
    {for(int var:v){func(var);}}
int main(){
    vector<int> v1={2,3,4,6,7,8,9};
    ForEach(v1,printValue);
    }
#+end_src

#+RESULTS:
: 2
: 3
: 4
: 6
: 7
: 8
: 9

* Operator Overloading
** Binary
#+begin_src C++ :results output
    #include<iostream>
    using namespace std;
    class Complex{
        int a,b;
        public:
            void set_data(int x,int y){a=x, b=y;}
            void show_data(){cout<<a<<" + "<<b<<"i";}
            //Complex add(Complex c) //aam zindegi
            Complex operator +(Complex c) //mentos zindegi
            {
                Complex temp;
                temp.a=a+c.a;
                temp.b=b+c.b;
                return(temp);
            }
        };
    int main(){
        Complex c1,c2,c3;
        c1.set_data(3,4);
        c2.set_data(5,6);
        //c3=c1.add(c2); //aam zindegi
        c3=c1+c2; // mentos zindegi [c3=c1.operator+(c2)]
        c3.show_data();
        return 0;
    }
#+end_src

#+RESULTS:
: 8 + 10i

#+begin_src C++ :results output
    #include<iostream>
    using namespace std;
    class Complex{
        int a,b;
        public:
            Complex(){}
            Complex(int m,int n):a(m),b(n){}
            void show_data(){cout<<a<<" + "<<b<<"i";}
            Complex operator +(Complex c)
            {
                return(Complex(a+c.a,b+c.b));
            }
        };
    int main(){
        Complex c1(1,2),c2(3,4),c3;
        //c3=c1.add(c2); //aam zindegi
        c3=c1+c2; // mentos zindegi [c3=c1.operator+(c2)]
        c3.show_data();
        return 0;
    }
#+end_src

#+RESULTS:
: 4 + 6i

** Unary
*** Single
#+begin_src C++ :results output
    #include<iostream>
    using namespace std;
    class Complex{
        int a,b;
        public:
            void set_data(int x,int y){a=x, b=y;}
            void show_data(){cout<<a<<" + "<<b<<"i";}
            Complex operator -()
            {
                Complex temp;
                temp.a=-a;
                temp.b=-b;
                return(temp);
            }
        };
    int main(){
        Complex c1,c2;
        c1.set_data(3,4);
        c2=-c1; // [c2=c1.operator-()]
        c2.show_data();
        return 0;
    }
#+end_src

#+RESULTS:
: -3 + -4i

#+begin_src C++ :results output
#include<iostream>
using namespace std;
class Example{
    public:
    void print() const{cout<<"Hello";}
    };
class ScopedExample{
    Example *ex;
    public:
        ScopedExample(Example *e):ex(e){}
        ~ScopedExample(){delete ex;}
        Example* operator->(){return ex;}
    };
int main(){
    ScopedExample se1=new Example();
    se1->print(); // se1.operator->()->print();
    }
#+end_src

#+RESULTS:
: Hello

*** Pre
#+begin_src C++ :results output
    #include<iostream>
    using namespace std;
    class Integer{
        int a;
        public:
            void set_data(int x){a=x;}
            void show_data(){cout<<a<<endl;}
            Integer operator ++()
            {
                Integer temp;
                temp.a=++a;
                return(temp);
            }
        };
    int main(){
        Integer c1,c2;
        c1.set_data(3);
        c2=++c1; // [c2=c1.operator++()]
        c1.show_data();
        c2.show_data();
        return 0;
    }
#+end_src

#+RESULTS:
: 4
: 4

*** Post
#+begin_src C++ :results output
    #include<iostream>
    using namespace std;
    class Integer{
        int a;
        public:
            void set_data(int x){a=x;}
            void show_data(){cout<<a<<endl;}
            Integer operator ++(int)
            {
                Integer temp;
                temp.a=a++;
                return(temp);
            }
        };
    int main(){
        Integer c1,c2;
        c1.set_data(3);
        c2=c1++; // [c2=c1.operator++(int)]
        c1.show_data();
        c2.show_data();
        return 0;
    }
#+end_src

#+RESULTS:
: 4
: 3
** Functor
#+begin_src C++ :results output
#include<iostream>
using namespace std;
class sqar{
    int var;
    public:
    sqar(){}
    sqar(int val):var{val}{}
    int operator()(int i)
        {return i*var;}
    };
int main(){
    sqar s(6);
    cout<<s(2)<<endl;
    cout<<s.operator()(3)<<endl;
    }
#+end_src

#+RESULTS:
: 12
: 18
* Lambda Function
#+begin_src C++ :results output
#include<iostream>
#include<functional>
using namespace std;
int main(){
    auto l=[n=2]()mutable{n++;return n*2;};
    cout<<l();
    // cout<<[n=2](){return n*2;}();
    // auto a=[](int num){return num*2;};
    const function<int(int)> &a=[](int num){return num*2;};
    cout<<a(3);
    // cout<<[](int num){return num*2;}(3);
    }
#+end_src

#+RESULTS:
: 66

* Outside Class Function
#+begin_src C++ :results output
    #include<iostream>
    using namespace std;
    class Complex{
        int a,b;
        public:
            void set_data(int,int);
            void show_data();
    };
    void Complex::set_data(int x,int y){a=x,b=y;}
    void Complex::show_data(){cout<<a<<" "<<b;}
    int main(){
        Complex c1;
        c1.set_data(3,4);
        c1.show_data();
        return 0;
        }
#+end_src

#+RESULTS:
: 3 4

* Static
** Static Member Variable / Class Variable
#+begin_src C++ :results output
#include<iostream>
using namespace std;
class a {
    static const int x;
    public:
        void f() { cout << x << endl; }
};
const int a::x=12;
int main(){
    a a1;
    a1.f();
    }
#+end_src

#+RESULTS:
: 12

- Must be assign with some value.
- If not assign value in class & not define ouside of class cause error(linking error).
- Non-const static variable can't be assign in class.
- Object independent, only one.

** Static Member Function
#+begin_src C++ :results output
#include<iostream>
using namespace std;
class Account{
    static float roi;
    public:
        // static void set_data(float r){roi=r;}
        static void set_data(float);
        void f(){cout<<roi;}
    };
float Account::roi;
void Account::set_data(float r){roi=r;}
int main(){
    Account::set_data(4.5f);
    Account a1;
    a1.f();
    }
#+end_src

#+RESULTS:
: 4.5

- Access only static variable without create object.
- Object independent, only one.
- To use static function static variable must be define outside of class.

* Constructor
- Member function of class
- Same name of class
- no return
- never static
- solve initialization problem

- When developer not create any constructor in class then, compiler create Default & Copy constructor.
- Compiler always call Default & Copy constructor, when a object created.
** Public Constructor
#+begin_src C++ :results output
  #include<iostream>
  using namespace std;
  class Complex{
      int a,b,*c;
      public:
	  Complex(int x,int y){a=x,b=y;} //Parameterize Constructor
	  Complex(int k){a=k;}
	  Complex(){a=0,b=0;} //Default Constructor
	  Complex(Complex &c){a=c.a,b=c.b;} //Copy Constructor
	  // Complex(Complex c){} //wrong Copy Constructor
    Complex(){c=new int;} //Dynamic Constructor
    // Dynammic constructor: when constructor has pointer that hold outside variable address.
  };
  int main(){
      Complex c1=Complex(3,4),c2=5,c3,c4(3,8),c5(c1);
      return 0;
  }
#+end_src

#+RESULTS:

** Private Constructor
#+begin_src C++ :results output
#include<iostream>
using namespace std;
class A{
    int a,b;
    static int k;
    A(){a=2,b=3;}
    public:
        void print(){cout<<a<<b;}
        static A* getInstance(){
            if(k==0){
                A *a = new A;
                k++;
                return(a);
                }
            else return(NULL);
            }
    };
int A::k=0;
int main(){
    A *a1;
    a1 = A::getInstance(); // Singleton object
    a1->print();

    A *a2;
    a2 = A::getInstance();
    if(a2!=NULL) a2->print();
    else cout<<"object not created";
    }
#+end_src

#+RESULTS:
: 23object not created

#+begin_src C++ :results output
#include <iostream>
using namespace std;

// class A
class A{
private:
    A(){
       cout << "constructor of A\n";
    }
    friend class B; // comment out this line will be error
};
class B{
public:
    B(){
        A a1;
        cout << "constructor of B\n";
    }
};
int main(){
    B b1;
}
#+end_src

#+RESULTS:
: constructor of A
: constructor of B

** Delete Compiler Constructor
#+begin_src C++ :results output
#include<iostream>
using namespace std;
class numprint{
    int a;
    public:
    numprint()=delete;
    numprint(int a1):a(a1){cout<<a;}
    };
int main(){
    numprint n1(5);
    }
#+end_src

#+RESULTS:
: 5

- I use delete when I want to assure that a class is called with an initializer. I consider it as a very elegant way to achieve this without runtime checks.
* Constructor Overloading
#+begin_src C++ :results output
#include<iostream>
using namespace std;
class person{
    string name;
    int age;
    public:
        explicit person(const string& n):name{n},age(-1){}
        explicit person(int a):name("unknown"),age(a){}
    };
void print(const person& p){}
int main(){
    // person p1= string("Real");
    person p1(string("Real"));
    // person p2= 25;
    person p2(25);
    print((person)"Qasl");
    // print(22);
    print(person(22));
    }
#+end_src

#+RESULTS:

* Destructor
** Public Destructor
#+begin_src C++ :results output
  #include<iostream>
  using namespace std;
  class Complex{
      int a,b,*c;
      public:
	  ~Complex(){cout<<"Destructor ";} //Destructor
  };
  int main(){
      Complex c1;
      return 0;
  }
#+end_src

#+RESULTS:
: Destructor
** Private & Delete Destructor
#+begin_src C++ :results output
#include<iostream>
using namespace std;
class Complex{
    private:
        ~Complex(){}
    };
class Integer{
    private:
        ~Integer()=delete;
    };
int main(){
    Complex *c1=new Complex;
    Integer *i1=new Integer;
    Complex &c2=*(new Complex);
    }
#+end_src

#+RESULTS:
** Virtual Destructor
#+begin_src C++ :results output
#include<iostream>
using namespace std;
class Base{
    public:
        Base(){cout<<"Base Constructor\n";}
        virtual ~Base(){cout<<"Base Destructor\n";}
};
class Derived:public Base{
    int* m_Array;
    public:
        Derived(){m_Array=new int[5];cout<<"Derived Constructor\n";}
        ~Derived(){delete[] m_Array;cout<<"Derived Destructor\n";}
};
int main(){
    Base* base=new Base();
    delete base;
    cout<<"-----------------------\n";
    Derived* derived=new Derived();
    delete derived;
    cout<<"-----------------------\n";
    Base* poly=new Derived();
    delete poly;
    }
#+end_src

#+RESULTS:
#+begin_example
Base Constructor
Base Destructor
-----------------------
Base Constructor
Derived Constructor
Derived Destructor
Base Destructor
-----------------------
Base Constructor
Derived Constructor
Derived Destructor
Base Destructor
#+end_example

* Friend Function
- Access any member of class indirectly.
- It has no caller object.
- Should not be defined with membership label.
#+begin_src C++ :results output
    #include<iostream>
    using namespace std;
    class Complex{
        int a,b;
        public:
            void set_data(int x,int y){a=x,b=y;}
            friend void fun(Complex);
        };
    void fun(Complex c){cout<<c.a+c.b;}
    int main(){
        Complex c1;
        c1.set_data(3,4);
        fun(c1);
        return 0;
        }
#+end_src

#+RESULTS:
: 7

- One friend function can become friend to more than one class.
#+begin_src C++ :results output
  #include<iostream>
  using namespace std;
  class B;
  class A{
      int a;
      public:
	  void set_data(int x){a=x;}
	  friend void fun(A,B);
      };
  class B{
      int b;
      public:
	  void set_data(int x){b=x;}
	  friend void fun(A,B);
      };
  void fun(A a1,B b1){cout<<a1.a+b1.b;}
  int main(){
      A o1;
      B o2;
      o1.set_data(3);
      o2.set_data(4);
      fun(o1,o2);
      return 0;
      }
#+end_src

#+RESULTS:
: 7

- Member function of one class can become friend to another class.
#+begin_src C++ :results output
  #include<iostream>
  using namespace std;
  class B;
  class A{
      int a;
      public:
	void fun();
	// {
	// 	B b1;
	// 	b1.b=100;
	// 	cout<<b1.b<<endl;
	// }
      };
  class B{
      int b;
      public:
	  friend void A::fun();
      };
   void A::fun()
      {
	  B b1;
	  b1.b=100;
	  cout<<b1.b<<endl;
      }
  int main(){
      A a1;
      a1.fun();
      return 0;
      }
#+end_src

#+RESULTS:
: 100

* Friend Operator Overloading
** Binary
*** Addition
#+begin_src C++ :results output
    #include<iostream>
    using namespace std;
    class Complex{
        int a,b;
        public:
            void set_data(int x,int y){a=x, b=y;}
            void show_data(){cout<<a<<" + "<<b<<"i";}
            friend Complex operator +(Complex,Complex);
        };
    Complex operator +(Complex X,Complex Y)
        {
            Complex temp;
            temp.a=X.a+Y.a;
            temp.b=X.b+Y.b;
            return(temp);
        }
    int main(){
        Complex c1,c2,c3;
        c1.set_data(3,4);
        c2.set_data(5,6);
        c3=c1+c2; // [c3=operator+(c1,c2)]
        c3.show_data();
        return 0;
    }
#+end_src

#+RESULTS:
: 8 + 10i

*** Input & Output
#+begin_src C++ :results output
    #include<iostream>
    using namespace std;
    class Complex{
        int a,b;
        public:
            void set_data(int x,int y){a=x, b=y;}
            void show_data(){cout<<a<<" + "<<b<<"i";}
            friend ostream &operator <<(ostream &,Complex);
            // friend istream &operator <<(istream &,Complex &);
        };
        ostream &operator <<(ostream &dout,Complex C){
                dout<<C.a<<" "<<C.b<<endl;
                return(dout);
            }
        // istream &operator <<(istream &din,Complex &C){
        //         din<<C.a<<C.b;
        //         return(din);
        //     }
    int main(){
        int a=2;
        cout<<a<<endl; // [cout.operator<<(a)]
        Complex c1,c2;
        c1.set_data(3,4);
        c2.set_data(5,6);
        cout<<c1<<c2; // [operator<<cout,c1)]
        return 0;
    }
#+end_src

#+RESULTS:
: 2
: 3 4
: 5 6

** Unary
*** Single
#+begin_src C++ :results output
    #include<iostream>
    using namespace std;
    class Complex{
        int a,b;
        public:
            void set_data(int x,int y){a=x, b=y;}
            void show_data(){cout<<a<<" + "<<b<<"i";}
            friend Complex operator -(Complex);
            };
        Complex operator -(Complex X)
        {
            Complex temp;
            temp.a=-X.a;
            temp.b=-X.b;
            return(temp);
        }
    int main(){
        Complex c1,c2;
        c1.set_data(3,4);
        c2=-c1; // [c2=operator-(c1)]
        c2.show_data();
        return 0;
    }
#+end_src
*** Pre
#+begin_src C++ :results output
    #include<iostream>
    using namespace std;
    class Integer{
        int a;
        public:
            void set_data(int x){a=x;}
            void show_data(){cout<<a<<endl;}
            friend Integer operator ++(Integer &);
        };
            Integer operator ++(Integer &X)
            {
                Integer temp;
                temp.a=++X.a;
                return(temp);
            }
    int main(){
        Integer c1,c2;
        c1.set_data(3);
        c2=++c1; // [c2=operator++(c1)]
        c1.show_data();
        c2.show_data();
        return 0;
    }
#+end_src

#+RESULTS:
: 4
: 4

*** Post
#+begin_src C++ :results output
    #include<iostream>
    using namespace std;
    class Integer{
        int a;
        public:
            void set_data(int x){a=x;}
            void show_data(){cout<<a<<endl;}
            friend Integer operator ++(Integer &);
        };
        Integer operator ++(Integer &X)
        {
            Integer temp;
            temp.a=X.a++;
            return(temp);
        }
    int main(){
        ostream &gout=cout;
        Integer c1,c2;
        c1.set_data(3);
        c2=++c1; // [c2=operator++(c1)]
        c1.show_data();
        c2.show_data();
        return 0;
    }
#+end_src

#+RESULTS:
: 4
: 3

* Inheritance
class Base_Class{};
class Derived_Class: Visibility_Mode Base_Class{};

- all members of Base_Class is available for Derived_Class. But not accessible in some cases.

** Visibility Modes
- Private
- Protected
- Public

1. Private members of Base_Class can't be accessible by Derived_Class.
2. class Derived_Class: private Base_Class{};
   then, protected & public members of Base_Class is private member of Derived_Class.
3. class Derived_Class: protected Base_Class{};
   then, protected & public members of Base_Class is protected member of Derived_Class.
4. class Derived_Class: public Base_Class{};
   then, protected & public members of Base_Class is protected & public member of Derived_Class.

#+begin_src C++ :results output
    #include<iostream>
    using namespace std;
    class array{
        // int a[10];
        public:
            int a[10];
            void insert(int index, int value)
            {a[index]=value;}
        };
    class Stack: private array{
        int top=0;
        public:
            void push(int value)
            {insert(top,value);
                top++;}
            void print(){
                for(int i=0;a[i]!='\0';i++)
                    cout<<a[i]<<endl;
                }
        };
    int main(){
        Stack s1;
        s1.push(34);
        //s1.insert(1,56); //error
        s1.print();
        return 0;
        }
#+end_src

#+RESULTS:
: 34
: 32607
: -1997211487
: 32607
: -1996276072
: 32607
: -1997422240
: 32607

** Inheritance Constructor & Destructor

1) Constructor in inheritance
   - Call first child then, parent
   - Exec first parent then, child

2) Destructure in inheritance
   - Call & exec first child then, parent

#+begin_src C++ :results output
#include<iostream>
using namespace std;
class A{
    int a;
    public:
        A(int k){a=k;cout<<"value of A "<<a<<endl;}
        ~A(){cout<<"A Destructor"<<endl;}
    };
class B: public A{
    int b;
    public:
        B(int x,int y):A(x){b=y;cout<<"value of B "<<x<<" "<<y<<endl;}
        ~B(){cout<<"B Destructor"<<endl;}
    };
int main(){
    B b1(5,8);
    }
#+end_src

#+RESULTS:
: value of A 5
: value of B 5 8
: B Destructor
: A Destructor

** Overriding (Virtual Function)
#+begin_src C++ :results output
#include<iostream>
using std::string;using std::cout;using std::endl;
class entity{
    public:
        virtual string getname(){return "entity";}
    };
class player:public entity{
    string player_name;
    public:
        player(string name):player_name(name){}
        string getname() override {return player_name;}
    };
void printname(entity *e)
    {cout<<e->getname()<<endl;}
int main(){
    entity e;
    printname(&e);
    player p("RP");
    printname(&p);
    }
#+end_src

#+RESULTS:
: entity
: RP

** Method Overriding & Method Hiding

- Virtual Function solve Method Overriding problem not Method Hiding problem.
#+begin_src C++ :results output
#include<iostream>
class A{
    //*_vptr
    public:
        void f1(){}
        void f2(){}
        virtual void f3(){}
        virtual void f4(){}
    };
class B: public A{
    public:
        void f1(){} //Method Overriding
        void f2(int x){} //Method Hiding
        void f3(){}
        void f4(int x){}
    };
int main(){
    B b1;
    b1.f1(); //B
    // b1.f2(); //error
    b1.f2(4); //B
    A *p;
    p=&b1;
    // p->*_vptr->vtable[f3,f4,...]
    p->f1(); //Early Binding //A
    p->f2(); //Early Binding //A
    p->f3(); //Late Binding //B ; without virtual function A
    p->f4(); //Late Binding //A
    // p->f4(5); //error
    return 0;
    }
#+end_src

#+RESULTS:
** Abstract Class

- We can't create object of Abstract class.
#+begin_src C++ :results output
#include<iostream>
class A{
    public:
        virtual void fun()=0; //Pure virtual function
    };
class B: public A{
    public:
        virtual void fun()=0;
    };
class C:public B{
    public:
        void fun(){}
    };
int main(){
    // A a1; //error
    // B b1; //error
    C c1;
    return 0;
    }
#+end_src

#+RESULTS:

* This
- This is a local object pointer in every instance member function containing address of the caller object.
- This pointer is used to refer caller object in member function.
- This pointer can't modify.

#+begin_src C++ :results output
#include<iostream>
using namespace std;
class Box{
    int l,b,h; //this
    public:
        void set_data(int l,int b,int h)
        {   Box *const b1=this;
            Box &b2=*this;
            b1->l=l,b2.b=b,this->h=h;}
        void show_data(){cout<<l<<" "<<b<<" "<<h;}
    };
int main(){
    Box smallbox;
    smallbox.set_data(12,10,15);
    smallbox.show_data();
    return 0;
    }
#+end_src

#+RESULTS:
: 12 10 15

* New & Delete
- C -> Complex *ptr=(struct Complex *)malloc(sizeof(struct Complex));
    -> int x;scanf("%d",&x);int *p=(int *)malloc(x*sizeof(int));
    -> free(ptr);free(p);
- C++ -> Complex *ptr=new Complex;
      -> int x;cin>>x;int *p=new int[x];
      -> delete ptr;delete p[];
- new & delete calls constructor & destructor
* Template
** Function Template
#+begin_src C++ :results output
#include<iostream>
using namespace std;
template <typename X,class Y>
X max(X a, Y b){
    return (a>b)?a:b;
    }
int main(){
    cout<<max(4.9,5)<<endl;
    cout<<max<float,int>(5.1,5)<<endl;
    return 0;
    }
#+end_src

#+RESULTS:
: 5
: 5.1

** Class Template || Generic Class
#+begin_src C++ :results output
#include<iostream>
using namespace std;
template <typename T,int N>
class Array{
    T arrp[N];
    public:
        int getSize() const {return N;}
    };
int main(){
    Array<int,5> array;
    cout<<array.getSize();
    }
#+end_src

#+RESULTS:
: 5

#+begin_src C++ :results output
#include<iostream>
using namespace std;
template <class X>
class ArrayList{
    struct ControlBlock{
        int capacity;
        int *arr;
        };
    ControlBlock *s;
    public:
        ArrayList(int cap){
            s=new ControlBlock;
            s->capacity=cap;
            s->arr=new int[cap];
            }
        void addElement(int index,X data){
            if(index>=0 && index<s->capacity)
            {s->arr[index]=data;}
            else{cout<<"Array index is not valid";}
            }
        void viewList(){
            for(int i=0;i<s->capacity;i++){
                cout<<s->arr[i]<<endl;
                }
            }
};
int main(){
    ArrayList <int>list1(4);
    list1.addElement(0,23);
    list1.addElement(1,43);
    list1.viewList();
    }
#+end_src

#+RESULTS:
: 23
: 43
: 0
: 0

* File Handling
** Write
#+begin_src C++ :results output
#include<iostream>
#include<fstream>
using namespace std;
int main(){
    // ofstream fout;
    fstream fout;
    fout.open("file.txt",ios::app|ios::binary);
    fout<<"Hello \\nRP";
    fout.close();
    return 0;
    }
#+end_src

#+RESULTS:

** Read
#+begin_src C++ :results output
#include<iostream>
#include<fstream>
using namespace std;
int main(){
    // ifstream fin;
    fstream fin;
    char ch;
    string s;
    fin.open("file.txt",ios::in);
    while(!fin.eof()){
        fin>>ch;
        cout<<ch;
        }
    getline(fin,s);
    cout<<endl<<s;
    fin.close();
    return 0;
    }
#+end_src

#+RESULTS:
: Hello\nRPP
* Initializers
#+begin_src C++ :results output
#include<iostream>
using namespace std;
class Dummy{
    int a,b;
    const int x;
    int &y;
    public:
        Dummy(int &n):a(2),b(3),x(5),y(n){}
    };
int main(){
    int m=6;
    Dummy d1(m);
    return 0;
    }
#+end_src

#+RESULTS:

#+begin_src C++ :results output
#include<iostream>
using namespace std;
class example1{
    public:
        example1(){cout<<"ex1 default constructor"<<endl;}
        example1(int a){cout<<"ex1 parameterise constructor"<<endl;}
    };
class example2{
    public:
        example2(){cout<<"ex2 default constructor"<<endl;}
        example2(int a){cout<<"ex2 parameterise constructor"<<endl;}
    };
class Example{
    example1 e1;
    example2 e2;
    public:
        Example():e2(example2(4)){
            e1=example1(3);
            }
    };
int main(){
    Example hello;
    }
#+end_src

#+RESULTS:
: ex1 default constructor
: ex2 parameterise constructor
: ex1 parameterise constructor

* Copy
** Shallow Copy
#+begin_src C++ :results output
#include<iostream>
using namespace std;
class Dummy{
    int a,b,*p;
    public:
        void set_data(int x,int y,int z)
        {a=x,b=y,*p=z;}
        void show_data()
        {cout<<"a:"<<a<<" b:"<<b<<" *p:"<<*p<<endl;}
        Dummy(){p=new int;}
        Dummy(Dummy &d)
        {a=d.a,b=d.b,p=d.p;}
    };
int main(){
    Dummy d1;
    d1.set_data(3,4,5);
    Dummy d2=d1;
    d2.show_data();
    return 0;
    }
#+end_src

#+RESULTS:
: a:3 b:4 *p:5

** Deep Copy
#+begin_src C++ :results output
#include<iostream>
using namespace std;
class Dummy{
    int a,b,*p;
    public:
        void set_data(int x,int y,int z)
        {a=x,b=y,*p=z;}
        void show_data()
        {cout<<"a:"<<a<<" b:"<<b<<" *p:"<<*p<<endl;}
        Dummy(){p=new int;}
        Dummy(Dummy &d){
            a=d.a,b=d.b;
            p=new int;
            *p=*(d.p);
        }
    };
int main(){
    Dummy d1;
    d1.set_data(3,4,5);
    Dummy d2=d1;
    d2.show_data();
    return 0;
    }
#+end_src

#+RESULTS:
: a:3 b:4 *p:5

* Type Conversion
** Primitive to Class
#+begin_src C++ :results output
#include<iostream>
using namespace std;
class Complex{
    int a,b;
    public:
        Complex(){}
        Complex(int k){a=k,b=0;}
        void set_data(int x,int y)
        {a=x,b=y;}
        void show_data()
        {cout<<"a:"<<a<<" b:"<<b;}
    };
int main(){
    Complex c1;
    int x=5;
    c1=x; //c1=Complex(x)
    c1.show_data();
    return 0;
    }
#+end_src

#+RESULTS:
: a:5 b:0

** Class to Primitive
#+begin_src C++ :results output
#include<iostream>
using namespace std;
class Complex{
    int a,b;
    public:
        void set_data(int x,int y)
        {a=x,b=y;}
        void show_data()
        {cout<<"a:"<<a<<" b:"<<b;}
        operator int(){return a;}
    };
int main(){
    Complex c1;
    c1.set_data(3,4);
    int x;
    x=c1; //x=c1.operator int()
    cout<<"x:"<<x<<endl;
    return 0;
    }
#+end_src

#+RESULTS:
: x:3

** Class to Another Class
#+begin_src C++ :results output
#include<iostream>
using namespace std;
class Product{
    int a,b;
    public:
        void set_data(int x,int y)
        {a=x,b=y;}
        int getA(){return a;}
        int getB(){return b;}
    };
class Item{
    int m,n;
    public:
        Item(){}
        Item(Product p){
            m=p.getA();
            n=p.getB();
            }
        void show_data()
        {cout<<"1st value : "<<m<<endl<<"2nd value : "<<n<<endl;}
    };
int main(){
    Product p1;
    Item i1;
    p1.set_data(3,4);
    i1=p1; //i1.Item(p1)
    i1.show_data();
    return 0;
    }
#+end_src

#+RESULTS:
: 1st value : 3
: 2nd value : 4
* Exception Handling
- Try and catch are linked, if anyone is missing then compile time error.
- Throw return object into catch arguments, if catch missing then runtime auto terminate.
- Throw must be used with values, otherwise runtime auto terminate.
#+begin_src C++ :results output
#include<iostream>
using namespace std;
void fun(){throw 10;}
int main(){
    int i=1;
    try{
        if(i==1){fun();}
        if(i==2){throw "Hello";}
        if(i==3){throw 4.5;}
        cout<<"In try";
        }
    // catch(int e){cout<<"Exception no: "<<e;}
    // catch(double e){cout<<"Exception no: "<<e;}
    // catch(char const* e){cout<<"Exception no: "<<e;}
    catch(...){cout<<"Exception no: ";}
    return 0;
    }
#+end_src

#+RESULTS:
: Exception no:

* Namespace
- Namespace is not a class, you can't create object of namespace. It is group of declaration.
- You can use an alias name for your namespace. Example: namespace ms=MySpace;
- There can be unnamed namespace too.
- Namespace can be extended.
  Example: file1.h and file2.h both have same namespace MySpace, then compiler create one namespace MySpace and all variables, functions & classes put on it.
#+begin_src C++ :results output
#include<iostream>
using namespace std;
namespace ISpace{
    int a;
    void f1();
    }
namespace MySpace{
    using namespace ISpace;
    class Hello{
        public:
            void hello();
        };
    }
void ISpace::f1(){cout<<"value of a: "<<ISpace::a<<endl;}
void MySpace::Hello::hello(){cout<<"Hello";}
int main(){
    MySpace::a=5;
    MySpace::f1();
    MySpace::Hello obj;
    obj.hello();
    return 0;
    }
#+end_src

#+RESULTS:
: value of a: 5
: Hello

* String
#+begin_src C++ :results output
#include<iostream>
// using namespace std;
using std::cout,std::endl,std::string;
int main(){
    string s1= "hello";
    string s2;
    s2=s1;//strcpy(s2,s1)
    cout<<s2<<endl;
    int i=s2>s1;//int i= strcmp(s2,s1)
    cout<<i<<endl;
    string s3;
    s3=s1+s2;//strcpy(s3,strcat(s1,s2))
    cout<<s3<<endl;
    }
#+end_src

#+RESULTS:
: hello
: 0
: hellohello

- String class support many constructor, some of them are
  - string()
  - string(const char *str)
  - string(const char &str)

#+begin_src C++ :results output
#include<iostream>
using std::string;
using namespace std::string_literals;
int main(){
    // same
    string s0 = "hello";
    string s1("hello");
    string s2 = string("hello");
    s1+=s2; //operation

    // same
    string name0 = string("Real") + "hello";
    string name1 = "Real"s + "hello";
    }
#+end_src

#+RESULTS:

* Const
#+begin_src C++ :results output
#include<iostream>
using std::cout,std::endl;
int main(){
    const int x=5; //for store address must use (pointer to const)
    int y=3;

    int const *p1; //pointer to const
    p1=&x;
    p1=&y;
    cout<<x<<endl;
    cout<<*p1<<endl;

    int *const p2=&y; //const pointer
    cout<<*p2<<endl;

    }
#+end_src

#+RESULTS:
: 5
: 3
: 3

#+begin_src C++ :results output
#include<iostream>
using namespace std;
class Foo{
    int a=2, *b;
    int mutable var;
    public:
        int getA() const{ // this function can't modify any member variable
            // a=5; //error
            var = 3;
            return a;
            }
        int const* const getB() const{
            // 1st const: whatever this function return can't modify whatever it points
            // 2st const: whatever this function return can't be modified when it use
            // 3st const: whatever this function return can't be modified in this function
            return b;
            }
    };
void print(const Foo &f1){ //can't change cbject variable, but if you use a non-const function you can change variable's value, so you must be use a const function.
    cout<<f1.getA()<<endl;
    }
int main(){
    Foo obj;
    // const int &x=obj.getB();
    // x++;
    print(obj);
    }
#+end_src

#+RESULTS:
: 2

#  LocalWords:  Initializers Destructor Const Cpp Unary Pre
* Smart pointers
#+begin_src C++ :results output
#include<iostream>
using namespace std;
class Example{
    public:
        Example(){cout<<"constructor created"<<endl;}
        ~Example(){cout<<"destructor called"<<endl;}
    };
class ScopedExample{
    Example *p;
    public:
        ScopedExample(Example *ptr):p(ptr){}
        ~ScopedExample(){delete p;}
    };
int main(){
    {
        Example *e1=new Example();
        ScopedExample e2=new Example(); // ScopedExample e2(new Example())
    }
    }
#+end_src

#+RESULTS:
: constructor created
: constructor created
: destructor called

** Unique Pointer
#+begin_src C++ :results output
#include<iostream>
#include<memory>
using namespace std;
class Example{
    public:
        Example(){cout<<"constructor created"<<endl;}
        ~Example(){cout<<"destructor called"<<endl;}
    };
int main(){
    {
        unique_ptr<Example> e0;
        unique_ptr<Example> e1(new Example());
        unique_ptr<Example> e2=make_unique<Example>();
        // unique_ptr<Example> e3=e2; // error, copy constructor & copy assignment operator are deleted
    }
    {
        unique_ptr<int> i1=make_unique<int>(25);
        unique_ptr<int> i2=move(i1);
        cout<<*i2<<endl;
        // cout<<*i1<<endl; // nullptr exception thrown
    }
    }
#+end_src

#+RESULTS:
: constructor created
: constructor created
: destructor called
: destructor called
: 25

** Shared Pointer
#+begin_src C++ :results output
#include<iostream>
#include<memory>
using namespace std;
class Example{
    public:
        Example(){cout<<"constructor created"<<endl;}
        ~Example(){cout<<"destructor called"<<endl;}
    };
int main(){
    {
        shared_ptr<Example> e1;
        {
            cout<<"Shared count "<<e1.use_count()<<endl;
            shared_ptr<Example> e2=make_shared<Example>();
            e1=e2;
            cout<<"Shared count "<<e1.use_count()<<endl;
        }
        cout<<"Shared count "<<e1.use_count()<<endl;
    }
    }
#+end_src

#+RESULTS:
: Shared count 0
: constructor created
: Shared count 2
: Shared count 1
: destructor called
** Weak Pointer
#+begin_src C++ :results output
#include<iostream>
#include<memory>
using namespace std;
void count(weak_ptr<int> &w,shared_ptr<int> &s){
    cout<<"Weak count "<<w.use_count()<<endl<<"Shared count "<<s.use_count()<<endl;
    }
int main(){
    weak_ptr<int> w0;
    {
        shared_ptr<int> s1=make_shared<int>(24);
        w0=s1;
        count(w0,s1);
        {
            // shared_ptr<int> s2=w0; // error, shared_ptr can't point to a weak_ptr
            shared_ptr<int> s2=s1;
            count(w0,s2);
        }
        count(w0,s1);
    }
    cout<<"Weak count "<<w0.use_count()<<endl;
    cout<<"Weak Expired? "<<w0.expired()<<endl;
    }
#+end_src

#+RESULTS:
: Weak count 1
: Shared count 1
: Weak count 2
: Shared count 2
: Weak count 1
: Shared count 1
: Weak count 0
: Weak Expired? 1

- std::weak_ptr is a very good way to solve the dangling pointer problem. By just using raw pointers it is impossible to know if the referenced data has been deallocated or not. Instead, by letting a std::shared_ptr manage the data, and supplying std::weak_ptr to users of the data, the users can check validity of the data by calling expired() or lock().

You could not do this with std::shared_ptr alone, because all std::shared_ptr instances share the ownership of the data which is not removed before all instances of std::shared_ptr are removed. Here is an example of how to check for dangling pointer using lock().

#+begin_src C++ :results output
#include <iostream>
#include <memory>

int main()
{
    // OLD, problem with dangling pointer
    // PROBLEM: ref will point to undefined data!

    int* ptr = new int(10);
    int* ref = ptr;
    delete ptr;

    // NEW
    // SOLUTION: check expired() or lock() to determine if pointer is valid

    // empty definition
    std::shared_ptr<int> sptr;

    // takes ownership of pointer
    sptr.reset(new int);
    *sptr = 10;

    // get pointer to data without taking ownership
    std::weak_ptr<int> weak1 = sptr;

    // deletes managed object, acquires new pointer
    sptr.reset(new int);
    *sptr = 5;

    // get pointer to new data without taking ownership
    std::weak_ptr<int> weak2 = sptr;

    // weak1 is expired!
    if(auto tmp = weak1.lock())
        std::cout << "weak1 value is " << *tmp << '\n';
    else
        std::cout << "weak1 is expired\n";

    // weak2 points to new data (5)
    if(auto tmp = weak2.lock())
        std::cout << "weak2 value is " << *tmp << '\n';
    else
        std::cout << "weak2 is expired\n";
}
#+end_src

#+RESULTS:
: weak1 is expired
: weak2 value is 5

* STL
** Vector(Dynamic Array)
#+begin_src C++ :results output
#include<iostream>
#include<vector>
using namespace std;
struct Vertex{
    float x,y,z;
    };
ostream& operator<<(ostream& dout,const Vertex &vertex){
    dout<<vertex.x<<","<<vertex.y<<","<<vertex.z<<endl;
    return dout;
    }
void Function(const vector<Vertex>& ver){}
int main(){
    vector<int> v1; // blank vector or zero length vector
    vector<string> v2{"hello","world"}; // two length vector
    vector<char> v3(5); // five length vector
    vector<char> v4(4,'s'); // four length vector filled with s
    vector<int> v5(5,3);
    vector<int>:: iterator it=v5.begin();
    v5.insert(it+2,4);
    for(int &i: v5)
        cout<<i<<endl;

    vector<Vertex> vertices;
    vertices.push_back({1,2,3});
    vertices.push_back({4,5,6});
    for(int i=0;i<vertices.size();i++)
        cout<<vertices[i]<<endl;
    vertices.erase(vertices.begin()+1);
    for(Vertex &v: vertices)
        cout<<v<<endl;
    Function(vertices);
    }
#+end_src

#+RESULTS:
#+begin_example
3
3
4
3
3
3
1,2,3

4,5,6

1,2,3

#+end_example
** Pair(Two value)
#+begin_src C++ :results output
#include<iostream>
#include<utility>
using namespace std;
std::pair<int, int> divide(int dividend, int divisor)
{
   int quotient=dividend / divisor;
   int remainder=dividend % divisor;
   return std::make_pair(quotient, remainder);
}
int main(){
std::pair<int, int> answer = divide(14,3);
    cout<<answer.first <<" == quotient ";
    cout<<answer.second << " == remainder";
}
#+end_src

#+RESULTS:
: 4 == quotient 2 == remainder

** Tuple(Multiple value)
#+begin_src C++ :results output
#include<iostream>
#include<tuple>
using namespace std;
int main(){
    tuple<string,int,int> t1;
    t1=make_tuple("India",16,10);
    cout<<get<0>(t1)<<endl;
    cout<<get<1>(t1)<<endl;
    cout<<get<2>(t1)<<endl;
    }
#+end_src

#+RESULTS:
: India
: 16
: 10

*** Tie Function
#+begin_src C++ :results output
// packing/unpacking tuples
#include <iostream>     // std::cout
#include <tuple>        // std::tuple, std::make_tuple, std::tie

int main ()
{
  int myint;
  char mychar;

  std::tuple<int,float,char> mytuple;

  mytuple = std::make_tuple (10, 2.6, 'a');          // packing values into tuple

  std::tie (myint, std::ignore, mychar) = mytuple;   // unpacking tuple into variables

  std::cout << "myint contains: " << myint << '\n';
  std::cout << "mychar contains: " << mychar << '\n';

  return 0;
}
#+end_src

#+RESULTS:
: myint contains: 10
: mychar contains: a

*** Return multiple values
#+begin_src C++ :results output
#include <tuple>

std::tuple<int, int> divide(int dividend, int divisor) {
    return  std::make_tuple(dividend / divisor, dividend % divisor);
}

#include <iostream>

int main() {
    using namespace std;

    int quotient, remainder;

    tie(quotient, remainder) = divide(14, 3);

    cout << quotient << ',' << remainder << endl;
}
#+end_src

#+RESULTS:
: 4,2

In C++17:

#+begin_src C++ :results output
#include <tuple>

std::tuple<int, int> divide(int dividend, int divisor) {
    return  {dividend / divisor, dividend % divisor};
}

#include <iostream>

int main() {
    using namespace std;

    auto [quotient, remainder] = divide(14, 3);

    cout << quotient << ',' << remainder << endl;
}
#+end_src

#+RESULTS:
: 4,2

or with structs:

#+begin_src C++ :results output
auto divide(int dividend, int divisor) {
    struct result {int quotient; int remainder;};
    return result {dividend / divisor, dividend % divisor};
}

#include <iostream>

int main() {
    using namespace std;

    auto result = divide(14, 3);

    cout << result.quotient << ',' << result.remainder << endl;

    // or

    auto [quotient, remainder] = divide(14, 3);

    cout << quotient << ',' << remainder << endl;
}
#+end_src

#+RESULTS:
: 4,2
: 4,2

** Map
#+begin_src C++ :results output
#include<iostream>
#include<map>
using namespace std;
int main(){
    map <int,string> c1;
    c1[100]= "hello";
    c1[102]= "world";
    map <int,string> c2{{100,"Hello"},{102,"World"}};
    }
#+end_src

#+RESULTS:
** Array
#+begin_src C++ :results output
#include<iostream>
#include<array>
using namespace std;
template<class T, size_t I>
void printArray(array<T, I> a)
{
    for (auto &i : a)
    {
        cout << i << '\n';
    }
}

int main()
{
    array<int, 3> intArray {1, 2, 3};
    array<double, 2> doubleArray {2.3, 5.5};
    cout << "Printing Int Array" << '\n';
    printArray(intArray);
    cout << "Printing Double Array" << '\n';
    printArray(doubleArray);

    return 0;
}
#+end_src

#+RESULTS:
: Printing Int Array
: 1
: 2
: 3
: Printing Double Array
: 2.3
: 5.5

#+begin_src C++ :results output
#include <iostream>
#include <array>

void PrintArray(const auto& data)
{
        std::cout << "[";
        for (unsigned i = 0; i < data.size(); i++){
                std::cout << data[i];
                if (i == data.size() - 1)
                        std::cout << "]";
                else
                        std::cout << ", ";
        }
        std::cout << std::endl;
}

int main()
{
        std::array <int, 5> data;
        data = {0, 5, 9, 8, 6};
        PrintArray(data);
        return 0;
}
#+end_src

#+RESULTS:
: [0, 5, 9, 8, 6]
* Thread
#+begin_src C++ :results output
#include<iostream>
#include<chrono>
#include<thread>
using namespace std;
using namespace std::literals::chrono_literals;
void sayhello(string name){
    cout<<"sayhello"<<this_thread::get_id()<<endl;
    for(int i=0; i<5 ;i++){
        this_thread::sleep_for(chrono::milliseconds(100));
        cout<<"hello"<<name<<endl;
        }
    }
class classThread{
    public:
        void operator()(string name){
            for(int i=0; i<5 ;i++){
                this_thread::sleep_for(chrono::milliseconds(100));
                cout<<"hello"<<name<<endl;
            }
            }
    };
void foo(){
    cout<<"foo started\n";
    thread det(sayhello,"detached");
    det.detach();
    cout<<"foo ended\n";
    }
int main(){
    thread funcptr(sayhello,"world");
    thread lambdaptr([](string name){
        for(int i=0; i<5 ;i++){
            this_thread::sleep_for(chrono::milliseconds(100));
            cout<<"hello"<<name<<endl;
        }
        },"lambda");
    thread class_thread(classThread(),"class");

    cout<<"functhread id = "<<funcptr.get_id()<<endl;
    cout<<"lambdathread id = "<<lambdaptr.get_id()<<endl;
    cout<<"classthread id = "<<class_thread.get_id()<<endl;

    funcptr.join();
    lambdaptr.join();
    class_thread.join();
    foo();

    cout<<"functhread id = "<<funcptr.get_id()<<endl;
    cout<<"lambdathread id = "<<lambdaptr.get_id()<<endl;
    cout<<"classthread id = "<<class_thread.get_id()<<endl;
    }
#+end_src

#+RESULTS:
#+begin_example
sayhello140045420250688
functhread id = 140045420250688
lambdathread id = 140045410223680
classthread id = 140045265978944
helloworld
hellolambda
helloclass
hellolambdahello
world
helloclass
helloworldhello
hellolambdaclass

helloworld
helloclass
hellolambda
helloworld
hellohellolambdaclass

foo started
foo ended
functhread id = thread::id of a non-executing thread
lambdathread id = thread::id of a non-executing thread
classthread id = thread::id of a non-executing thread
sayhello140045265978944
#+end_example
